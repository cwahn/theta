use std::{any::Any, fmt::Debug, future::Future};

use futures::FutureExt;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use uuid::Uuid;

use crate::{
    actor_instance::ActorState,
    actor_ref::ActorHdl,
    error::ExitCode,
    message::{Continuation, MsgPack, RawSignal},
    prelude::{ActorRef, WeakActorRef},
};

pub type ActorId = uuid::Uuid;

// ! Currently, the restart sementic should be considered ill-designed.
// todo Redesign resilience system.

// pub trait ActorConfig: Clone + Send  + 'static {
//     type Actor: Actor;

//     /// An initialization logic of an actor.
//     /// - Panic-safe; panic will get caught and escalated
//     fn initialize(
//         ctx: Context<Self::Actor>,
//         cfg: &Self,
//     ) -> impl Future<Output = Self::Actor> + Send ;
// }

// ! Args is not even necessary, since it was introduced for child actor spawning, but now there is no such concept any more.

pub trait Actor: Sized + Debug + Send + 'static {
    // type Args: Send;
    type Msg: Send + Sync + Serialize + for<'d> Deserialize<'d>;
    type StateReport: for<'a> From<&'a Self>
        + Clone
        + Serialize
        + for<'d> Deserialize<'d>
        + Send
        + Sync;

    // #[allow(unused_variables)]
    // fn initialize(args: Self::Args) -> impl Future<Output = Self> + Send;

    // ! Monitoring feature will be moved to the report system.
    /// A wrapper around message processing for optional monitoring.
    /// - Panic-safe; panic will get caught and escalated
    #[allow(unused_variables)]
    fn process_msg(&mut self, msg: Self::Msg, k: Continuation) -> impl Future<Output = ()> + Send {
        async move { todo!() }
    }

    /// Called on drop, or termination
    /// - Panic-safe; but the panic will not be escalated but ignored or logged
    /// - In case of termination, state might be corrupted since it does not rollback on panic
    /// - Since the message loop is already stopped, any message to self will be lost
    #[allow(unused_variables)]
    fn on_exit(&mut self, exit_code: ExitCode) -> impl Future<Output = ()> + Send {
        __default_on_exit(self, exit_code)
    }

    #[allow(unused_variables)]
    fn hash_code(&self) -> u64 {
        0 // no-op by default
    }

    #[allow(unused_variables)]
    fn state_report(&self) -> Self::StateReport {
        self.into() // no-op by default
    }

    fn spawn(self) -> impl Future<Output = ActorRef<Self>> + Send;

    // ! Would like to remove registry
    // Should not implemented by user.
    // #[cfg(feature = "remote")]
    // const __IMPL_ID: ImplId;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Nil;

pub fn __default_on_exit<A: Actor>(
    _actor: &mut A,
    _exit_code: ExitCode,
) -> impl std::future::Future<Output = ()> + Send {
    async move {}
}

// Implementations

impl<T> From<&T> for Nil
where
    T: Actor,
{
    fn from(_: &T) -> Self {
        Nil
    }
}

// ! temp Design

pub trait Behavior<A: Actor>: Into<A::Msg> + Send + 'static {
    type Return: Send + Sync + Serialize + for<'d> Deserialize<'d> + 'static;

    fn process(state: &mut A, msg: Self) -> impl Future<Output = Self::Return> + Send;

    fn process_to_any(
        state: &mut A,
        msg: Self,
    ) -> impl Future<Output = Box<dyn Any + Send>> + Send {
        async move {
            let ret = Self::process(state, msg).await;
            Box::new(ret) as Box<dyn Any + Send>
        }
        .boxed()
    }

    fn process_to_bytes(state: &mut A, msg: Self) -> impl Future<Output = Vec<u8>> + Send {
        async move {
            let ret = Self::process(state, msg).await;
            postcard::to_allocvec(&ret).expect("Failed to serialize message")
        }
        .boxed()
    }
}

// AutoGenerated class

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Msg1 {
    pub data: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Msg2 {
    pub value: i32,
}

#[derive(Debug)]
pub struct SomeActor {
    pub name: String,
}

impl Actor for SomeActor {
    type Msg = __Generated__SomeActor__MSG;
    type StateReport = String;

    fn spawn(self) -> impl Future<Output = ActorRef<SomeActor>> + Send {
        async move {
            let (msg_tx, msg_rx) = mpsc::unbounded_channel();
            let (sig_tx, sig_rx) = mpsc::unbounded_channel();

            let actor_hdl = ActorHdl(sig_tx);
            let actor = ActorRef {
                id: Uuid::new_v4(),
                tx: msg_tx,
            };

            // todo It should be generic spawn
            tokio::spawn(__generated_some_actor_loop(
                actor.downgrade(),
                actor_hdl.clone(),
                sig_rx,
                msg_rx,
                self,
            ));

            // (actor_hdl, actor)
            // todo Register actor_hdl for global registry

            actor
        }
    }
}

// Make String to stiesfy the trait bound
impl From<&SomeActor> for String {
    fn from(actor: &SomeActor) -> Self {
        actor.name.clone()
    }
}

// ! Should be marked as embassy task
async fn __generated_some_actor_loop(
    actor: WeakActorRef<SomeActor>,
    actor_hdl: ActorHdl,
    sig_rx: mpsc::UnboundedReceiver<RawSignal>,
    msg_rx: mpsc::UnboundedReceiver<MsgPack<SomeActor>>,
    state: SomeActor,
) {
    let config = ActorState::new(actor, actor_hdl, sig_rx, msg_rx, state);

    config.exec().await;
}

impl Behavior<SomeActor> for Msg1 {
    type Return = String;

    fn process(state: &mut SomeActor, msg: Self) -> impl Future<Output = Self::Return> + Send {
        async move {
            println!("Processing Msg1 with data: {}", msg.data);
            format!("Processed Msg1 in actor: {}", state.name)
        }
    }
}

impl Behavior<SomeActor> for Msg2 {
    type Return = String;

    fn process(state: &mut SomeActor, msg: Self) -> impl Future<Output = Self::Return> + Send {
        async move {
            println!("Processing Msg2 with value: {}", msg.value);
            format!("Processed Msg2 in actor: {}", state.name)
        }
    }
}

// Generated code
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum __Generated__SomeActor__MSG {
    Msg1(Msg1),
    Msg2(Msg2),
}

impl From<Msg1> for __Generated__SomeActor__MSG {
    fn from(msg: Msg1) -> Self {
        __Generated__SomeActor__MSG::Msg1(msg)
    }
}

impl From<Msg2> for __Generated__SomeActor__MSG {
    fn from(msg: Msg2) -> Self {
        __Generated__SomeActor__MSG::Msg2(msg)
    }
}

// Actor serialized as Ident@PublicKey
// Lookup a Actor with Ident, what should I expect?
// Open a new byte stream, create lookup for Ident
// If there is something, if should should be AnyActorRef.
// AnyActorRef should be able to take any bytes from network

// pub trait AnyActorRef {
//     fn process_bytes(&self, msg_k: Vec<u8>) -> impl Future<Output = ()> + Send;
// }

// // ! Problem is that each export of actor will result spawning, and it should reference the actor.
// // ! Which is not allowed in embassy, since all the task should be free async fn.

// impl<A: Actor> AnyActorRef for ActorRef<A> {
//     fn process_bytes(&self, msg_k_bytes: Vec<u8>) -> impl Future<Output = ()> + Send {
//         async move {
//             // Deserialize the message
//             let (msg, k_dto): (A::Msg, ContinuationDto) =
//                 postcard::from_bytes(&msg_k_bytes).expect("Failed to deserialize message");
//             // Process the message
//             self.send_dyn(msg, k_dto.into())
//                 .expect("Failed to send message");
//         }
//     }
// }

// No type checking until it asks message.
// Actually asking will not even notify the type mismatch.
// Without the registry.

use std::{collections::HashMap, hash::Hash};

use serde::{Deserialize, Serialize};

use theta_macros::{ActorConfig, actor, intention};

use crate::{
    actor::{self, Actor, Nil},
    context::Context,
    message::{Continuation, Message},
    prelude::{ActorRef, GlobalContext},
};

#[derive(Debug, Clone, ActorConfig, Hash)]
pub struct Manager {
    workers: HashMap<String, ActorRef<Worker>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateWorker {
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWorker {
    pub name: String,
}

pub struct Worker {}

impl Actor for Worker {
    type Msg = Nil;
    type StateReport = Nil; // Which means reporting is no-op
}

// #[impl_id("da0c631b-e3d6-4369-bff2-80939f4ef177")]
#[actor("d89de30e-79c5-49b6-9c16-0903ac576277")]
impl Actor for Manager {
    type StateReport = Nil; // Which means reporting is no-op

    intention! {
        async |msg: CreateWorker| {
            println!("Creating worker with name: {}", msg.name);

            let worker = ctx.spawn(Worker {}).await;
            self.workers.insert(msg.name.clone(), worker.clone());
        };

        async |GetWorker { name }| -> Option<ActorRef<Worker>> {
            println!("Getting worker with name: {}", name);

            if let Some(worker) = self.workers.get(&name).cloned() {
                worker.raw_send(Nil, Continuation::nil()).unwrap();
                Some(worker)
            } else {
                println!("Worker with name {} not found", name);
                None
            }
        };
    }

    // async fn process_msg(&mut self, ctx: Context<Self>, msg: Self::Msg, k: Continuation) -> () {
    //     match msg {
    //         Self::Msg::CreateWorker(create_worker) => {
    //             if k.is_nil() {
    //                 let _ = create_worker.process(self, ctx).await;
    //             } else {
    //                 let any_ret = create_worker.process_to_any(self, ctx).await;
    //                 k.send(any_ret);
    //             }
    //         }
    //         Self::Msg::GetWorker(get_worker) => {
    //             if k.is_nil() {
    //                 let _ = get_worker.process(self, ctx).await;
    //             } else {
    //                 let any_ret = get_worker.process_to_any(self, ctx).await;
    //                 k.send(any_ret);
    //             }
    //         }
    //     }
    // }

    // intention! {...} Should be expanded to
    // async fn process_msg(&mut self, ctx: Context<Self>) -> () {...}
}

// Should be auto generated by the macro

// #[allow(non_camel_case_types)]
// #[derive(Debug, Clone, Serialize, Deserialize)]
// enum __GeneratedManagerMsg {
//     CreateWorker(CreateWorker),
//     GetWorker(GetWorker),
// }

// impl Message<Manager> for CreateWorker {
//     type Return = ();

//     fn process(
//         state: &mut Manager,
//         ctx: Context<Manager>,
//         msg: Self,
//     ) -> impl Future<Output = Self::Return> + Send {
//         async move {
//             println!("Creating worker with name: {}", msg.name);
//             let worker = ctx.spawn(Worker {}).await;
//             state.workers.insert(msg.name.clone(), worker.clone());
//         }
//     }
// }

// impl Into<__GeneratedManagerMsg> for CreateWorker {
//     fn into(self) -> __GeneratedManagerMsg {
//         __GeneratedManagerMsg::CreateWorker(self)
//     }
// }

// impl Message<Manager> for GetWorker {
//     type Return = Option<ActorRef<Worker>>;

//     fn process(
//         state: &mut Manager,
//         ctx: Context<Manager>,
//         msg: Self,
//     ) -> impl Future<Output = Self::Return> + Send {
//         async move {
//             println!("Getting worker with name: {}", msg.name);
//             if let Some(worker) = state.workers.get(&msg.name).cloned() {
//                 worker.raw_send(Nil, Continuation::nil()).unwrap();
//                 Some(worker)
//             } else {
//                 None
//             }
//         }
//     }
// }

// impl Into<__GeneratedManagerMsg> for GetWorker {
//     fn into(self) -> __GeneratedManagerMsg {
//         __GeneratedManagerMsg::GetWorker(self)
//     }
// }

// Message

// #[impl_id("3b2b8513-bb43-4bc5-a6d7-ea392df44ce0")]
// impl Message<CreateWorker> for Manager {
//     type Return = ();

//     async fn process(&mut self, _ctx: Context<Self>, msg: CreateWorker) -> Self::Return {
//         println!("Creating worker with name: {}", msg.name);
//     }
// }

// #[impl_id("5c3b8513-bb43-4bc5-a6d7-ea392df44ce1")]
// impl Message<GetWorker> for Manager {
//     type Return = Option<String>; // Assuming worker returns a name

//     async fn process(&mut self, _ctx: Context<Self>, msg: GetWorker) -> Self::Return {
//         println!("Getting worker with name: {}", msg.name);
//         Some(msg.name) // Placeholder return
//     }
// }

#[tokio::test]
async fn test_manager_behavior() {
    let ctx = GlobalContext::initialize().await;

    let msgs: Vec<Box<dyn Message<Manager>>> = vec![
        Box::new(CreateWorker {
            name: "Worker1".to_string(),
        }),
        Box::new(GetWorker {
            name: "Worker1".to_string(),
        }),
    ];

    let serialized_msgs = msgs
        .iter()
        .map(|msg| postcard::to_allocvec_cobs(msg).unwrap())
        .collect::<Vec<_>>();

    let deserialized_msgs: Vec<Box<dyn Message<Manager>>> = serialized_msgs
        .into_iter()
        .map(|mut msg| postcard::from_bytes_cobs(msg.as_mut_slice()).unwrap())
        .collect();

    let manager = ctx.spawn(Manager {}).await;

    for msg in deserialized_msgs {
        let _ = manager.send_raw(msg, Continuation::nil());
    }
}

use core::{any::Any, fmt::Debug};

#[cfg(feature = "std")]
use std::{
    any::Any,
    boxed::Box,
    format,
    future::Future,
    println,
    string::String,
    sync::{LazyLock, RwLock},
    vec::Vec,
};

#[cfg(feature = "alloc")]
use alloc::{boxed::Box, format, string::String, vec::Vec};

use futures::FutureExt;
use rustc_hash::FxHashMap;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use uuid::Uuid;

use crate::{
    actor_instance::ActorState,
    actor_ref::{ActorHdl, ActorRef},
    error::ExitCode,
    message::{Continuation, MsgPack, RawSignal},
};

pub type ActorId = uuid::Uuid;

pub static ACTORS: LazyLock<RwLock<FxHashMap<ActorId, ActorHdl>>> =
    LazyLock::new(|| RwLock::new(FxHashMap::default()));

// ! Args is not even necessary, since it was introduced for child actor spawning, but now there is no such concept any more.

pub trait Actor: Sized + Debug + Send + 'static {
    // type Args: Send;
    type Msg: Send + Sync + Serialize + for<'d> Deserialize<'d>;
    type StateReport: for<'a> From<&'a Self>
        + Clone
        + Serialize
        + for<'d> Deserialize<'d>
        + Send
        + Sync;

    // #[allow(unused_variables)]
    // fn initialize(args: Self::Args) -> impl Future<Output = Self> + Send;

    // ! Monitoring feature will be moved to the report system.
    /// A wrapper around message processing for optional monitoring.
    #[allow(unused_variables)]
    fn process_msg(&mut self, msg: Self::Msg, k: Continuation) -> impl Future<Output = ()> + Send;

    /// Called on drop, or termination
    /// - In case of termination, state might be corrupted since it does not rollback on panic
    /// - Since the message loop is already stopped, any message to self will be lost
    #[allow(unused_variables)]
    fn on_exit(&mut self, exit_code: ExitCode) -> impl Future<Output = ()> + Send {
        __default_on_exit(self, exit_code)
    }

    #[allow(unused_variables)]
    fn hash_code(&self) -> u64 {
        0 // no-op by default
    }

    #[allow(unused_variables)]
    fn state_report(&self) -> Self::StateReport {
        self.into() // no-op by default
    }

    fn spawn(self) -> impl Future<Output = ActorRef<Self>> + Send;

    // ! Would like to remove registry
    // Should not implemented by user.
    // #[cfg(feature = "remote")]
    // const __IMPL_ID: ImplId;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Nil;

pub fn __default_on_exit<A: Actor>(
    _actor: &mut A,
    _exit_code: ExitCode,
) -> impl std::future::Future<Output = ()> + Send {
    async move {}
}

// Implementations

impl<T> From<&T> for Nil
where
    T: Actor,
{
    fn from(_: &T) -> Self {
        Nil
    }
}

// ! temp Design

pub trait Message<A: Actor>: Into<A::Msg> + Send + 'static {
    type Return: Send + Sync + Serialize + for<'d> Deserialize<'d> + 'static;

    fn process(state: &mut A, msg: Self) -> impl Future<Output = Self::Return> + Send;

    fn process_to_any(
        state: &mut A,
        msg: Self,
    ) -> impl Future<Output = Box<dyn Any + Send>> + Send {
        async move {
            let ret = Self::process(state, msg).await;
            Box::new(ret) as Box<dyn Any + Send>
        }
    }

    fn process_to_bytes(state: &mut A, msg: Self) -> impl Future<Output = Vec<u8>> + Send {
        async move {
            let ret = Self::process(state, msg).await;
            postcard::to_allocvec(&ret).expect("Failed to serialize message")
        }
    }
}

// AutoGenerated class

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Msg1 {
    pub data: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Msg2 {
    pub value: i32,
}

#[derive(Debug)]
pub struct SomeActor {
    pub name: String,
}

impl Actor for SomeActor {
    type Msg = __SomeActor__Msg;
    type StateReport = String;

    fn process_msg(&mut self, msg: Self::Msg, k: Continuation) -> impl Future<Output = ()> + Send {
        async move {
            match msg {
                __SomeActor__Msg::Msg1(msg) => {
                    if k.is_nil() {
                        let _ = Msg1::process(self, msg).await;
                    } else {
                        let any_ret = Msg1::process_to_any(self, msg).await;
                        k.send_and_forget(any_ret);
                    }
                }
                __SomeActor__Msg::Msg2(msg) => {
                    if k.is_nil() {
                        let _ = Msg2::process(self, msg).await;
                    } else {
                        let any_ret = Msg2::process_to_any(self, msg).await;
                        k.send_and_forget(any_ret);
                    }
                }
            }
        }
    }

    fn spawn(self) -> impl Future<Output = ActorRef<SomeActor>> + Send {
        async move {
            let (msg_tx, msg_rx) = mpsc::unbounded_channel();
            let (sig_tx, sig_rx) = mpsc::unbounded_channel();

            let actor_hdl = ActorHdl(sig_tx);
            let actor = ActorRef {
                id: Uuid::new_v4(),
                tx: msg_tx,
            };

            // todo It should be generic spawn
            tokio::spawn(__generated_some_actor_loop(sig_rx, msg_rx, self));

            // todo Make no_std
            ACTORS.write().unwrap().insert(actor.id, actor_hdl);

            actor
        }
    }
}

// Make String to stiesfy the trait bound
impl From<&SomeActor> for String {
    fn from(actor: &SomeActor) -> Self {
        actor.name.clone()
    }
}

// ! Should be marked as embassy task
async fn __generated_some_actor_loop(
    sig_rx: mpsc::UnboundedReceiver<RawSignal>,
    msg_rx: mpsc::UnboundedReceiver<MsgPack<SomeActor>>,
    state: SomeActor,
) {
    let config = ActorState::new(sig_rx, msg_rx, state);

    config.exec().await;
}

impl Message<SomeActor> for Msg1 {
    type Return = String;

    fn process(state: &mut SomeActor, msg: Self) -> impl Future<Output = Self::Return> + Send {
        async move { format!("Processed Msg1 in actor: {}", state.name) }
    }
}

impl Message<SomeActor> for Msg2 {
    type Return = String;

    fn process(state: &mut SomeActor, msg: Self) -> impl Future<Output = Self::Return> + Send {
        async move { format!("Processed Msg2 in actor: {}", state.name) }
    }
}

// Generated code
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum __SomeActor__Msg {
    Msg1(Msg1),
    Msg2(Msg2),
}

impl From<Msg1> for __SomeActor__Msg {
    fn from(msg: Msg1) -> Self {
        __SomeActor__Msg::Msg1(msg)
    }
}

impl From<Msg2> for __SomeActor__Msg {
    fn from(msg: Msg2) -> Self {
        __SomeActor__Msg::Msg2(msg)
    }
}

// Actor serialized as Ident@PublicKey
// Lookup a Actor with Ident, what should I expect?
// Open a new byte stream, create lookup for Ident
// If there is something, if should should be AnyActorRef.
// AnyActorRef should be able to take any bytes from network

// pub trait AnyActorRef {
//     fn process_bytes(&self, msg_k: Vec<u8>) -> impl Future<Output = ()> + Send;
// }

// // ! Problem is that each export of actor will result spawning, and it should reference the actor.
// // ! Which is not allowed in embassy, since all the task should be free async fn.

// impl<A: Actor> AnyActorRef for ActorRef<A> {
//     fn process_bytes(&self, msg_k_bytes: Vec<u8>) -> impl Future<Output = ()> + Send {
//         async move {
//             // Deserialize the message
//             let (msg, k_dto): (A::Msg, ContinuationDto) =
//                 postcard::from_bytes(&msg_k_bytes).expect("Failed to deserialize message");
//             // Process the message
//             self.send_dyn(msg, k_dto.into())
//                 .expect("Failed to send message");
//         }
//     }
// }

// No type checking until it asks message.
// Actually asking will not even notify the type mismatch.
// Without the registry.
